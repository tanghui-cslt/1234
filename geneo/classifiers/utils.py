import os
import numpy as np
import keras
from keras import Sequential
from keras.layers import Conv2D, Softmax, MaxPooling2D, Dense, Flatten
from geneo.constants import CNN_DICT, FC_DICT
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import seaborn as sns
from tabulate import tabulate
sns.set_context("paper")



def generate_latex_table(array, header, concatenate_axis=None):
    if concatenate_axis is not None:
        array = np.concatenate(array, axis=concatenate_axis)
    return tabulate(array, headers=header, tablefmt="latex")


def build_cnn(input_shape, num_classes, cnn_dict = {}, fc_dict = {}):
    """Builds a convolutional neural network as a sequential model in keras
    by using the specifics in cnn_dict for the convolutional part and
    fc_dict for the fully connected and classifier part (softmax), respectively.

    Parameters
    ----------
    input_shape : tuple
        Shape of the input data (single sample, not batch)
    num_classes : int
        Number of classes
    cnn_dict : dict
        Dictionary describing the convoluional part parameters of the form
        :const:`~geneo.constants.CNN_DICT`
    fc_dict : type
        Dictionary describing the fully-connected part, see
        :function:`~geneo.classifiers.utils.build_fc`

    Returns
    -------
    keras.Sequential
        A convolutional neural network as a keras model initialized followed the
        specified parameters
    """
    model = Sequential()
    num_units = cnn_dict['num_units']
    kernels = cnn_dict['kernels']
    strides_cnn = cnn_dict['strides_cnn']
    acts = cnn_dict['activations']
    strides_pool = cnn_dict['strides_pool']
    pools = cnn_dict['pools']
    structure = cnn_dict['structure']
    initializers = cnn_dict['initializers']
    trainable = cnn_dict["trainable"]
    conv_count = 0
    pool_count = 0

    for i, l_type in enumerate(structure):
        if l_type == "conv" and i ==0:
            model.add(Conv2D(num_units[conv_count],
                             kernels[conv_count],
                             strides=strides_cnn[conv_count],
                             activation=acts[conv_count],
                             kernel_initializer =initializers[conv_count],
                             data_format = "channels_last"))
                             #input_shape=input_shape))
                             #trainable = trainable[conv_count]))
            conv_count += 1
        elif l_type == "conv":
            model.add(Conv2D(num_units[conv_count], kernels[conv_count],
                             strides=strides_cnn[conv_count],
                             kernel_initializer =initializers[conv_count],
                             activation=acts[conv_count],
                             trainable = trainable[conv_count]))
            conv_count += 1
        elif l_type == "pool":
            model.add(MaxPooling2D(pool_size=pools[pool_count],
                                   strides=strides_pool[pool_count]))
            pool_count += 1

        #print ([conv_count,pool_count])


    fc_dict['init_model'] = model
    build_fc(None, num_classes, **fc_dict)
    return model

def build_fc(input_shape=(784,), num_classes=2, architecture = None,
             num_layers=2, num_units = [64, 100],
             activations = ['relu', 'relu'], init_model = None):
    """Generates a fully-connected model according to the parameters specified
    as keyword arguments and with a softmax of size num_classes as lasst layer

    Parameters
    ----------
    input_shape : tuple
        Shape of the input data (single sample, not batch)
    num_classes : int
        Number of classes
    architecture : str
        a dummy parameter initialized to "fc" if the network is not part of a
        cnn
    num_layers : int
        Number of fully connected hidden layers (excluding input and classifier)
    num_units : list
        Number of units per input + hidden layer [u1, u2, ...]
    activations : list
        Activation per input + hidden layer ['relu', 'elu', ...]
    init_model : keras.Sequential
        A model to wich add the fully-connected structure generated by the
        function

    Returns
    -------
    keras.Sequential
        A fully-connected neural network as a keras model initialized followed
        the specified parameters

    """
    if init_model is None:
        model = Sequential()
        model.add(Dense(num_units[0], activation=activations[0],
                        input_shape = input_shape))
    else:
        model = init_model
        model.add(Flatten())

    for i in range(num_layers-1):
        model.add(Dense(num_units[i+1], activation=activations[i+1]))

    model.add(Dense(num_classes, activation='softmax'))
    return model

def plot_net_history(history, axs=None, show = False, save_to=None,
                     add_labels = True):
    if isinstance(history, list):
        history_dict = {'geneo_init':history[1].history,
                        'glorot_init':history[0].history}
        history = history[0]
    #print(history.history.keys())
    if axs is None:
        fig, axs = plt.subplots(1,2)
    axs[0].plot(history.history['loss'], 'b', label='Training')
    axs[0].plot(history.history['val_loss'], 'r',
                label="Validation")
    axs[1].plot(history.history['accuracy'], 'b')
    axs[1].plot(history.history['val_accuracy'], 'r')
    if add_labels:
        axs[0].set_title("Loss")
        axs[1].set_title("Accuracy")
        axs[0].legend()
    #axs[1].set_ylim([0,1])
    #axs[0].set_ylim([0,10])
    if show:
        plt.show()
    if save_to is not None:
        plt.savefig(save_to)
        save_to = os.path.splitext(save_to)[0] + '_history.npy'
        np.save(save_to, history_dict)


def get_diags_for_training(diags, inf_fill = 100, architecture = "fc"):
    """Given a set of persistence diagrams organized as
    [[D(I_1, f_1), ... D(I_1, f_n)],...,[D(I_m, f_1), ... D(I_m, f_n)]]
    Returns a numpy array of shape (num_img, num_funcs*max_len_diag*2)
    if the architecture is fully-connected, or
    (num_img, num_funcs, max_len_diag*2, 1) if architecture is convolutional.

    Parameters
    ----------
    diags : list
        list of persistence diagrams organized by image
    inf_fill : float
        value to be used to fill eventual ifinity values in the persistence
        diagrams
    architecture : str
        "fc" for fully-connected architectures and "cnn" for convolutional ones.

    Returns
    -------
    np.ndarray
        The vector or matrices generated from the persistence diagrams, with
        first dimension equal to the number of images for training.
    """
    length = get_max_num_points(diags)
    num_images = len(diags) #number of images in training set
    num_ops = len(diags[0])
    if architecture == "fc":
        vecs_per_ops = 2*num_ops*length
        vectorized_diags = np.zeros((num_images, vecs_per_ops))
    elif architecture == "cnn":
        vecs_per_ops = (length, 2*num_ops)
        vectorized_diags = np.zeros((num_images,)+ vecs_per_ops)
    else:
        raise NotImplementedError("Ooops, it seems we should implement this!")
    print("mat shape ", vectorized_diags.shape)

    for i, diags_per_meas_func in enumerate(diags):
        if architecture == "fc":
            vecs = diags2vectors(diags_per_meas_func, length,
                                 inf_fill=inf_fill)
            vectorized_diags[i,] = vecs.reshape([vecs_per_ops])
        elif architecture == "cnn":
            vecs = diags2images(diags_per_meas_func, length,
                                inf_fill = inf_fill)
            vectorized_diags[i,] = vecs

    if architecture == "cnn":
        vectorized_diags = np.expand_dims(vectorized_diags,3)
    return vectorized_diags

def get_max_num_points(diags):
    """Returns the maximum number of rows (points) a diagram will have. This is
    necessary to pad or crop all the diagrams to the same length.
    """
    return int(np.median([len(d) for op_diags in diags for d in op_diags]))

def diags2vectors(diags, length, inf_fill):
    """Organizes diagrams related to the same image, i.e. list of the form
    [D(I_i,f_1), ..., D(I_i, f_n)] in a matrix of vectors of the same length
    """
    return np.asarray([diag2vector(d, length, inf_fill) for d in diags])

def diag2vector(diag, length, inf_fill):
    """Transforms a diagram in a vector of length length
    """
    l = np.array([[p.birth, p.death] if p.death < np.inf else
                  [p.birth, inf_fill] for p in diag]).ravel()
    delta = length - len(diag)
    if delta < 0:
        l = l[:length]
    else:
        pad = 2*(delta)
        pad = np.zeros(pad)
        l = np.concatenate((l, pad))
    return l

def diags2images(diags, length, inf_fill):
    """Organizes diagrams related to the same image, i.e. list of the form
    [D(I_i,f_1), ..., D(I_i, f_n)] in a tensor of matrices of shape [n, length]
    """
    ret = np.asarray([diag2image(d, length, inf_fill) for d in diags])
    return ret.reshape([ret.shape[1],-1])

def diag2image(diag, length, inf_fill):
    """Organizes a diagram as a (2, length) image
    """
    l = np.array([[p.birth, p.death] if p.death < np.inf else
                  [p.birth, inf_fill] for p in diag])
    delta = length - len(diag)
    if delta < 0:
        l = l[:length]
    else:
        pad = (delta,2)
        pad = np.zeros(pad)
        l = np.concatenate((l, pad))
    return l
